逻辑架构

1、常规的C/S架构中的最外层：鉴权、连接处理

2、解析查询、优化 （优化器会向存储引擎询问执行操作的成本和表数据的统计信息）

3、存储引擎

==*== 在5.7.2 版本开始将查询缓存层标记为弃用，8.0版本中完全被移除。（为什么被弃用：随着并发性要求的增高，查询缓存层起不到太大的作用。）缓存重心迁移到Redis或者Memcached。



并发控制

多个线程同时对数据进行读写就会遇到并发的问题。

处理上述的读写访问的系统，一种经典的解决方案是：实现一种共享锁/排他锁，也叫做读锁/写锁的锁系统。

读锁是共享的，不互相阻塞的，一个资源可以被多个客户端同时访问；写锁是排他的，也就是说一个写锁即会阻塞其他的写锁，也会阻塞读锁，防止一个客户端读取正在写入的资源。



锁的粒度

如果要进一步的提高并发性，就要确保锁定的对象是具有选择性的，尽量只锁定需要修改的数据，而不是所有的资源。



锁定策略

在执行锁的时候，也会产生开销，比如获取锁， 释放锁，检查锁是否空闲。对锁的管理和对数据的读写需要进行平衡。



MySQL对锁做出的平衡

MySQL的不同的存储引擎给出了不同的锁策略和不同的锁粒度。锁粒度的控制可以优化某个场景的性能，但是针对其他的场景可能会导致负优化。



MySQL中比较重要的两种锁策略

表锁：table lock 是 MySQL 中最基本也是开销最小的锁策略。

行锁：rowlock 可以最大程度的支持并发，也带来了最大的锁开销，比如谁拥有了这些锁，拥有了多长时间，以及何时清理行级别锁。

行级锁是存储引擎实现的，不是服务器实现的，

[MySQL Innodb 引擎锁介绍](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)



事务

事务就是一组SQL语句作为工作单元以原子方式进行处理。

事务的特性：ACID  原子性：Atomicity、一致性：Consistency、隔离性：Isolation、持久性：Durability

原子性：Atomicity 一个事务中的SQL要么成功要么失败。

一致性：Consistency 从一个一致性状态转移到下一个一致性状态，如果事务没有被提交，一致性状态不应该改变。

隔离性：Isolation 通常来说一个事务未提交以前对其他的事务都是不可见的，这是隔离性带来的结果。但是会有不同的隔离级别，所以通常情况下是不可见的，有时候也会可见。

持久性：Durability 事务一旦提交所有的数据都会被保存到数据库中，不管程序奔溃或者系统奔溃数据也不会丢失。持久性也分为很多的级别，比如三地两中心等物理上的持久化。



隔离级别

READ UNCOMMITTED（未提交读） 在事务中可以看到其他的事务未提交的更改，这个隔离级别会有很多的问题，即读取未提交的数据也叫做**脏读**，而且从性能上来说也不会比其他的隔离级别好太多，所以这种隔离级别不经常使用。

READ COMMITTED（提交读）这是大多数数据库的默认隔离级别，但是MySQL不是。一个事物可以看到其他事务已提交的数据，但是该事务在提交之前所做的操作对于其他的事务是不可见的，这个隔离级别仍然有着不可重复读的问题。**这意味着同一事务中两次执行相同语句，可能会看到不同的数据结果。**

REPEATABLE READ（可重复读）是默认的隔离级别。 这种隔离级别解决了上一个隔离级别的不可重复读的问题，保证了在同一个事务中多次读取相同行数据的结果是一样的。但是理论上还是无法解决**幻读**的问题。所谓的幻读就是当前的事务在读取某个范围的数据时，其他的事务在该范围中**插入**了数据，导致该事务读取时出现了幻行。MySQL是通过**多版本并发控制（MVCC）**解决的幻读的问题。

SERIALIZABLE（可串行化）是最高的隔离级别，通过强制事务按照顺序执行，使事物之间不可能发生发生冲突，从而解决了前面说的幻读问题。原理就是在读取的每一行数据上面都加锁，但是也带来了大量的锁超时和性能问题，实际中很少使用。



以上的各个隔离级别带来的问题和解决的问题：

| 隔离级别                     | 脏读 | 不可重复度 | 幻读 | 加锁读 |
| :--------------------------- | :--: | :--------: | :--: | :----: |
| READ UNCOMMITTED（未提交读） |  是  |     是     |  是  |   否   |
| READ COMMITTED（提交读）     |  否  |     是     |  是  |   否   |
| REPEATABLE READ（可重复读）  |  否  |     否     |  是  |   否   |
| SERIALIZABLE（可串行化）     |  否  |     否     |  否  |   是   |



死锁

InnoDB引擎处理死锁的方式是将**持有最少行级排他锁的事务回滚**（这是一种最容易回滚的近似算法）。



















