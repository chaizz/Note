索引是一种快速找到记录的**数据结构**

B-Tree索引 

我们把它读作B+树索引，是一种特殊的树形结构。

自适应哈希索引

InnoDB 发现当某些索引值被频繁的访问时，会在原有的b+树索引上在构建一个哈希索引，使其也具备了哈希索引的优势。这些操作是InnoDB自动完成的，用户无法控制，不过可以通过参数关闭这个特性。

B+树索引的一些限制：

- 不符合最左前缀。即a、b、c三个索引只使用b、c索引。
- 不能跳过索引中的列。
- like 条件， 但是%在开头的情况下不会走索引（也没那么绝对）



全文索引

它查找的是文本中的关键词，而不是直接比较索引中的值。



前缀索引

有时候为了提升索引的性能，同时也节省索引空间，可以只对字段的前一部分字符进行索引。但是也有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY操作，也无法使用前缀索引做覆盖扫描。



多列索引

错误的多列索引是为每列创建独立的索引，或者按照错误的顺序创建多列索引。

MySQL引入了一种叫“索引合并”（index merge）的策略，它在一定程度上可以使用表中的多个单列索引来定位指定的行。在这种情况下，查询能够同时使用两个单列索引进行扫描，并将结果进行合并。

虽然索引合并有时候效果不错，但是也从侧面说明了索引建立的很糟糕：

- 优化器对索引做相交操作时（通常发生在多个and条件），意味着使用多列索引可能会更好，而不是单个列的索引。
- 优化器对索引做联合操作时（通常发生在多个and条件），通常在算法的缓存、排序、合并上做大量的操作需要消耗cpu资源。
- 更加重要的时候优化器不会把这些计算到查询成本中，使得查询的成本被低估。

> 如果在EXPLAIN中看到有索引合并，那么就应该好好检查一下查询语句的写法和表的结构，看是不是已经是最优的。也可以通过参数optimizer_switch来关闭索引合并功能。



如何选择合适的索引列顺序？

一个经验：通盘考虑，应该避免大量随机I/O和排序。如果不考虑排序和分组将选择性最高的列放在最前面是比较高性能的。

