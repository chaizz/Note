---
title: MQTT基础认知
author: chaizz
date: 2021-09-26
tags: MQTT
categories: MQ
photos: ["https://origin.chaizz.com/Snipaste_2023-06-08_18-31-00.png"]
---

​             

<!--more-->

# MQTT

> [MQTT](https://mqtt.org/) 是一种基于发布/订阅模式的轻量级消息==传输协议==，专门针对低带宽和不稳定网络环境的物联网应用而设计，可以用极少的代码为联网设备提供实时可靠的消息服务。MQTT 协议广泛应用于物联网、移动互联网、智能硬件、车联网、智慧城市、远程医疗、电力、石油与能源等领域。

MQTT 协议由 Andy Stanford-Clark （IBM）和 Arlen Nipper（Arcom，现为 Cirrus Link）于 1999 年发布。 按照 Nipper 的介绍，MQTT 必须具备以下几点：

- 简单容易实现
- 支持 QoS（设备网络环境复杂）
- 轻量且省带宽（因为那时候带宽很贵）
- 数据无关（不关心 Payload 数据格式）
- 有持续地会话感知能力（时刻知道设备是否在线）





MQTT Qos

  QoS 0： 最多交付一次

​    缺点：

​      是可能会丢失消息，消息丢失的频率依赖于你所处的网络环境，并且可能使你错过断开连接期间的消息。

​    优点是投递的效率较高。



  QoS 1 - 至少交付一次

​    优点：

​      QoS 1 可以保证消息到达。

​    缺点

​      会有重复的消息，如果关注消息重复则需要我们自己处理一些消息重复的问题， 且资源消耗也比Qos 0 大一些。



  QoS 2 - 只交付一次

​    优点

​      QoS 2 既可以保证消息到达，也可以保证消息不会重复。

​    缺点：

​      传输成本（资源消耗）较高。



使用场景：

  以下情况下可以选择 QoS 0

​    可以接受消息偶尔丢失，传输一些高频且不那么重要的数据，比如传感器数据，周期性更新，即使遗漏几个周期的数据也可以接受。

​    在同一个子网内部的服务间的消息交互，或其他客户端与服务端网络非常稳定的场景。



  以下情况下可以选择 QoS 1

​    对系统资源消耗较为关注，希望性能最优化。

​    且消息不能丢失，但能接受并处理重复的消息, 所以适合传输一些较为重要的数据，比如下达关键指令、更新重要的有实时性要求的状态等。

​    处理消息重复的简单方法：一个比较常用且简单的方法是，在每个 PUBLISH 报文的 Payload 中都带上一个时间戳或者一个单调递增的计数，

​    这样上层业务就可以根据当前收到消息中的时间戳或计数是否大于自己上一次接收的消息中的时间戳或计数来判断这是否是一个新消息。



  以下情况下可以选择 QoS 2

​    不能忍受消息丢失（消息的丢失会造成生命或财产的损失），且不希望收到重复的消息。

​    数据完整性与及时性要求较高的银行、消防、航空等行业。







MQTT 主题

  主题类似url路径, 使用斜杠 / 进行分层

  通常不建议主题以 / 开头或结尾，例如 /chat 或 chat/

  MQTT的主体不需要手动创建或删除， 在订阅和发布时会自动创建。



MQTT 主题通配符包含单层通配符 “+” 及多层通配符 “#”，主要用于客户端一次订阅多个主题



单层主题：单层通配符必须占据整个层级

  \+ 有效

  sensor/+ 有效

  sensor/+/temperature 有效

  sensor+ 无效（没有占据整个层级）

多层主题： 多层通配符表示它的父级和任意数量的子层级，在使用多层通配符时，它必须占据整个层级并且必须是主题的最后一个字符

  \# 有效，匹配所有主题

  sensor/# 有效

  sensor/bedroom# 无效（没有占据整个层级）

  sensor/#/temperature 无效（不是主题最后一个字符）



系统级别的主体：主要用于获取 MQTT 服务器自身运行状态、消息统计、客户端上下线事件等数据

  $SY



共享订阅 （解决问题①）

  是 MQTT 5.0 引入的新特性，用于在多个订阅者之间实现订阅的负载均衡，MQTT 5.0 规定的共享订阅主题以 $share 开头。

  虽然 MQTT 协议在 5.0 版本才引入共享订阅，但是 EMQX 从 MQTT 3.1.1 版本开始就支持共享订阅。

  

  例如： $share/<group-name>/topic   $share/<group-name> 是主题前缀（<group-name> 群组名，可以是任意utf8字符串）  topic 是真正的主主题

  对于 MQTT 5.0 以下的版本，EMQX 还支持不带群组的共享订阅前缀 $queue

  



排他订阅

  例如  $exclusive/a/1  前缀：$exclusive/  真正的主题 a/1

  

  需要手动开启



主题相关建议：

  建议一个客户端订阅的主题数量最好控制在 10 个以内

  建议主体层级为7个以内

  通配符主题性能弱于普通主题

  不建议使用 # 订阅所有主题；

  不建议主题以 / 开头或结尾，例如 /chat 或 chat/；

  不建议在主题里添加空格及非 ASCII 特殊字符；

  同一主题层级内建议使用下划线 _ 或横杆 - 连接单词（或者使用驼峰命名）；

  尽量使用较少的主题层级；

  当使用通配符时，将唯一值的主题层（例如设备号）越靠近第一层越好。例如，device/00000001/command/# 比device/command/00000001/# 更好。









问题①：针对同一主题的多个订阅这如何只消费一次消息？

可以通过broker共享订阅机制来解决此问题。共享订阅是在多个订阅者之间实现负载均衡的订阅方式： (5.0以下的低版本)

  通过修改etc/emqx.conf 配置文件中的以下配置：

​    \# 其中random表示在所有订阅者中随机选择，round_robin表示按照订阅顺序，sticky表示一直发往上次选取的订阅者，hash表示按照发布者 ClientID 的哈希值。

​    broker.shared_subscription_strategy = random

​    \# 适用于 QoS1 QoS2 消息，启用时在其中一个组离线时，将派发给另一个组

​    broker.shared_dispatch_ack_enabled = true









MQTT 保留消息

  在 publish 时设置 retained 的值True, 即可将最后一条消息设置为保留消息。



需要注意的是，在保留消息发布前订阅主题，将不会收到保留消息。需要待保留消息发布后，重新订阅该主题，才会收到保留消息。



保留消息的存储和删除

  服务器只会为每个主题保留最新的一条消息，保存的时间与服务器的设置有关。

  删除保留消息的方式：

​    1、客户端往某个主题发送一个 Payload 为空的保留消息，服务端就会删除这个主题下的保留消息；

​    2、在某些客户端上删除

​    3、MQTT 5.0 新增了消息过期间隔属性，发布时可使用该属性设置消息的过期时间，不管消息是否为保留消息，都将会在过期时间后自动被删除。







MQTT 遗嘱消息

  是 MQTT 为那些可能出现 意外断线 的设备提供的将 遗嘱 优雅地发送给第三方的能力。

  例如：

​    网络故障或网络波动，设备在保持连接周期内未能通讯，连接被服务端关闭

​    设备意外掉电

​    设备尝试进行不被允许的操作而被服务端关闭连接，例如订阅自身权限以外的主题等

  

  will_set() 必须在connect（）之前调用才能产生任何效果。

  

字段设置

  如果订阅该遗嘱主题（Will Topic）的客户端不能保证遗嘱消息发布时在线，那么建议为遗嘱消息设置 Will Retain，避免订阅端错过遗嘱消息。

  



MQTT Keep Alive

  Keep Alive 为 0~65535 的一个整数，代表客户端发送两次 MQTT 协议包之间的最大间隔时间。









